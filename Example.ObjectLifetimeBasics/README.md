# Example.ObjectLifetimeBasics

- **Кратко:** базовое знакомство с управляемой кучей, созданием объектов, ссылками и поколениями.

## Теория
- **Управляемая куча** — область памяти CLR, где размещаются объекты ссылочных типов. Разработчик не освобождает объекты вручную — это делает GC.
- **Ссылка vs объект:** переменная хранит ссылку на объект в куче, а не сам объект. Присвоение `null` разрывает связь, но не форсирует сборку.
- **Инструкция `newobj`:** компилятор генерирует CIL `newobj`, CLR выделяет память, вызывает конструктор и двигает «указатель следующего объекта».
- **Поколения (0/1/2):** новые объекты — Gen0; уцелевшие продвигаются в Gen1/Gen2. GC чаще чистит молодые поколения.

## Что делает пример
1. Выводит `GC.MaxGeneration + 1` и примерный объём памяти через `GC.GetTotalMemory(false)`.
2. Создаёт объект `new object()` и показывает его поколение `GC.GetGeneration(obj)`.
3. Обнуляет ссылку (`obj = null`), вызывает `GC.Collect()` и `GC.WaitForPendingFinalizers()` и показывает изменение памяти.

## Как интерпретировать вывод
- Поколение нового объекта обычно `0`.
- После `Collect()` объём используемой памяти может уменьшиться, но это не гарантировано (фоновые потоки, фрагментация, кэш JIT и т.д.).
- `null` не удаляет объект немедленно — это лишь делает его кандидатом на сборку.

## Полезные ссылки
- Руководство: «Fundamentals of Garbage Collection in .NET» (docs.microsoft.com / learn.microsoft.com).
- Справочник: `System.GC`.

Запуск:
```
dotnet run
```
