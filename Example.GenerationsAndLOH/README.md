# Example.GenerationsAndLOH

- **Кратко:** как GC работает с поколениями (0/1/2) и почему большие объекты попадают в LOH.

## Теория
- **Поколения:** новые объекты находятся в Gen0; если переживают сборку — продвигаются в Gen1/Gen2. GC чаще всего проверяет и собирает Gen0.
- **Эфемерные поколения:** Gen0 и Gen1 — «младшие» поколения, сборка которых минимально влияет на паузы.
- **LOH (Large Object Heap):** объекты ~85 000+ байт (например, крупные массивы) размещаются в отдельной куче. LOH обычно рассматривается при сборке Gen2 и реже компактизируется.
- **Промоция:** уцелевшие объекты повышают поколение, что сокращает их частые проверки GC.

## Что делает пример
1. Печатает счётчики сборок `GC.CollectionCount(0/1/2)` до нагрузки.
2. Создаёт «шум» из множества мелких аллокаций (нагрузка на Gen0).
3. Выделяет большой массив `byte[100_000]` → объект попадает в LOH.
4. Печатает поколение этого большого массива и вызывает `GC.Collect()`.
5. Снова выводит счётчики сборок — видно, какие поколения были собраны.

## Как интерпретировать вывод
- Большой массив, как правило, имеет поколение `2` (размещён в LOH).
- После `Collect()` счётчики Gen0/Gen1 обычно увеличиваются; Gen2 растёт реже.
- Это иллюстрация; конкретные значения зависят от среды и аллокаций.

## Полезные ссылки
- Large Object Heap (LOH) — официальная документация .NET.
- Generations in .NET GC.

Запуск:
```
dotnet run
```
